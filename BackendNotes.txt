# ByteStore – Backend Project Documentation

**Stack:** ASP.NET Core 8 Web API, EF Core 8, PostgreSQL, Redis, Serilog, FluentValidation, Identity + JWT, Stripe (payments), .

**Architecture:** Onion Architecture (Domain-centric). No CQRS. Service + Repository + Unit of Work. Controllers with Endpoint grouping.

**Repo layout (monorepo):**

```
/ByteStore
  /src
    /Core
      /Domain
        /Entities
        /Repositories
      /Application
        /Services
        /DTOs
        /Validators
        /IServices
        /Helpers
        /Exceptions
        DependencyInjection.cs
      /External
        /Api (ASP.NET Core host)
          /Extensions (DI, HealthChecks,..)
          /Middlewares (global handler , cors)
          appsettings.json
          Program.cs
          secret.json
        /Persistence (Infrastructure)
          /Database (DbContext, Configurations)
          /Migrations
          /Repositories
          /Seeders
          /Integration (Payment, Email,..)
          DependencyInjection.cs
        /Presentation (apis)
            /Controllers (DbContext, Configurations)
            AssymblylReference.cs
    /test

  /deploy
    docker-compose.yml
  /docs
    ERD.png / API.postman_collection.json
```

---

## 1) Executive Summary

ByteStore backend is a modular eCommerce API with a clean domain model, split by concerns using Onion Architecture. The API exposes resources for catalog (products, categories, brands), customer (accounts, addresses, wishlists), shopping flow (cart, orders, payments, shipments), and admin (inventory, pricing, promotions).

---

## 2) Goals & Non‑Functional Requirements

* **Scalability:** stateless API, cache-heavy (Redis), DB connection pooling, async I/O.
* **Security:** JWT, refresh tokens, HTTPS, role-based + policy-based authorization (Customer, Admin), data validation and rate limiting.
* **Reliability:** health checks, retries, idempotency keys on payments.
* **Observability:** structured logging (Serilog), request tracing, metrics, audit logs.
* **Performance:** pagination, filtering, sorting; EF compiled queries; output caching for catalog.
* **Maintainability:** SOLID, repository/specification pattern, fluent validation, unit/integration tests.
* **Portability:** Dockerized, environment-driven configuration.

---

## 3) Onion Architecture Overview

* **Domain (Core):** business rules, entities, enums, repository interfaces. No external dependencies.
* **Application (Core):** use-case orchestration via services. Defines DTOs, mappings, and validation. Depends only on Domain.
* **Infrastructure (External → Persistence):** EF Core DbContext, repository implementations, integrations (Stripe, SendGrid, storage), Redis cache providers. Depends on Core.
* **API (External → Api):** composition root. Configures DI, middleware, endpoints, Swagger, auth, health checks.

**Request flow:** `Api Endpoint → Application Service → Domain Entities (via Repositories & UnitOfWork) → DbContext`. Cross-cutting: logging, validation, caching.

---

## 4) Domain Model

**Key Entities**

    Address – id,street, city, state, postalCode, country, isPrimary, addressType, userId → (FK to Customer).
    Brand – id, name, description, logoUrl, products (list of Product).
    Category – id, name, description, imageUrl, parentCategoryId (nullable), parentCategory (ref), subCategories (list of Category), products (list of Product).
    Customer – firstName, lastName, dateOfBirth, orders (list of Order), addresses (list of Address), shoppingCart (ref), reviews (list of ProductReview).
    Order – orderDate, totalAmount, status (Pending, Processing, Shipped, Delivered, Cancelled), userId, shippingAddressId, billingAddressId, user (ref Customer), shippingAddress (ref Address), billingAddress (ref Address), orderItems (list of OrderItem).
    OrderItem – id, quantity, unitPrice, orderId, productId, order (ref Order), product (ref Product).
    Product – id, name, description, price, stockQuantity, isActive, createdAt, updatedAt, categoryId, brandId, category (ref Category), brand (ref Brand), specifications (list of ProductSpecification), orderItems (list of OrderItem), cartItems (list of CartItem), reviews (list of ProductReview), images (list of ProductImage).
    ProductImage – id, imageUrl, isPrimary, title, productId, product (ref Product).
    ProductReview – id, title, content, rating, createdOn, productId, userId, product (ref Product), customer (ref Customer).
    Identity:
        AppRole
        AppUser
    Redis:
        ShoppingCart – CustomerId, cartItems (list of CartItem).
        CartItem – productId, quantity, name , brand,category,price,imageUrl



**Aggregates**

* Product, Order, Cart.

**Invariants & Rules Examples**
* Cannot add to cart if `stockQuantity < requestedQty`.
* Order totals = Σ(items) − discounts + shipping + tax.
* Review allowed only if customer purchased the product.
---

## 5) Persistence & Data Modeling

**EF Core** with Fluent configurations.

* Soft-delete via `IsDeleted` + global query filters.
* Decimal precision for Money fields.
* Indexes: `Product(categoryId, brandId)`, `Order(orderNo)`.

**Unit of Work**

* `IUnitOfWork` with `SaveChangesAsync()` wrapping DbContext transaction.

**Repositories**

* `IProductRepository`, `ICartRepository`, `IOrderRepository`, `ICustomerRepository`, `IReviewRepository`.
* Query via **Specification pattern** (e.g., `ProductsByFiltersSpec`).

**Caching**

* Redis for product lists, product details, categories tree.
* Cache invalidation on writes via events.

---

## 6) Application Layer

**Services (Use-cases)**

* `CatalogService`: list/filter/paginate products, product details, categories/brands.
* `CartService`: create/get cart, add/update/remove item, merge anonymous → customer.
* `OrderService`: checkout, place order, apply promotion, calculate totals.
* `PaymentService`: create payment intent (Stripe), confirm, webhook handling.
* `AccountService`: register, login, manage addresses, tokens.
* `ReviewService`: add/update/remove review.
* `AdminService`: CRUD products, categories, brands, inventory movements.

**Validation** with FluentValidation on DTOs.

---

## 7) API Design (Minimal APIs or Controllers)

**Conventions**

* RESTful resource endpoints under `/api/v1/…`
* JSON, UTC times, RFC 7807 ProblemDetails for errors.
* Pagination: `pageNumber`, `pageSize`; Sorting: `sort`; Filtering by query params.

**Endpoints (selected)**

* **Auth & Account**: register, login, refresh, account info, addresses.
* **Catalog**: products list/detail, categories tree, brands, reviews.
* **Cart**: get cart, add/update/remove items.
* **Orders**: place order, list orders, order details.
* **Payments**: payment intent, webhook.
* **Admin**: CRUD products/categories, manage inventory.

---

## 8) Security & Identity

* ASP.NET Core Identity with JWT auth.
* Password hashing, email confirmation, lockout policy.
* **Roles:** Customer, Admin.
* Refresh tokens stored with rotation.
* Rate limiting on auth and product search endpoints.

---

## 9) Cross‑Cutting

* **Global Exception Handling** → ProblemDetails mapper.
* **Validation Pipeline**.
* **Logging** → Serilog.
* **Caching** → Redis.
* **Email** → SendGrid/SMTP service abstraction.

---

## 10) Environment & Configuration

* `appsettings.json` + environment-specific configs.
* **Required settings:**

  * `ConnectionStrings:Default`
  * `Jwt:Issuer`, `Jwt:Audience`, `Jwt:Key`
  * `Redis:Connection`
  * `Stripe:ApiKey`, `Stripe:WebhookSecret`
  * `Serilog` configuration

---

## 11) Build & Run

**Backend**

```
cd src/External/Api
dotnet ef database update --project ../Persistence
dotnet runDocker Compose (/deploy/docker-compose.yml)
```

```
```

---

## 12) Testing Strategy

* **Unit Tests** (Domain, Application): xUnit + FluentAssertions.
* **Integration Tests** (API): WebApplicationFactory, Testcontainers for SQL + Redis.
* **Contract Tests**: Verify DTOs/OpenAPI.
* **Load Tests**: k6 or JMeter.

---

## 13) Observability & Ops

* **Health Checks:** `/health`, `/health/ready`.
* **Metrics:** `/metrics` (Prometheus).
* **Dashboards:** Grafana + Loki/Seq for logs.

---

## 14) Coding Guidelines

* Naming: `PascalCase` for types, `camelCase` for locals.
* Controllers/Endpoints thin; logic in services.
* Use async/await everywhere.

---

## 15) Delivery Roadmap

1. Foundation: skeleton, DI, EF, Identity, JWT, Serilog.
2. Catalog: products/categories/brands APIs.
3. Cart: anonymous cart, cookie, add/update/remove.
4. Account: register/login/addresses.
5. Checkout: order placement, Stripe intent, webhooks.
6. Admin: product/category management, inventory.
7. Reviews & Wishlist.
8. Caching & Performance.

** To store Image we use ImageKit.Io service **

** for Auth we use JWT with refresh token with email verification **

** i am using ratelimiting ** 

** for health check i used normal endpoint /health just return json response and Health Check UI
    and its configuration in extensions and program.cs


** NOTE: after adding HealthCheck when u do migration will give error tells u
    "More than one DbContext was found. Specify which one to use. Use the '-Context' parameter for PowerShell commands and the '--context' parameter for dotnet commands."
    so u should specifiy the AppDbContext when u add command like 
        Add-Migration removeCartShopping -Context AppDbContext
        Update-Database -Context AppDbContext
    and that problem because after you added HealthChecks, your project now has more than one DbContext:
        Your main AppDbContext
        Another internal DbContext created by HealthChecks (if you’re using database storage for them)
    So EF Core doesn’t know which one you want when running Add-Migration or Update-Database.

/// my notes
* PK 
    User, Product, Category, Brand → int (كفاية).
    Order, Payment, Shipment → Guid (عشان IDs دي غالبًا بتيجي من بره أو محتاج تخزنها Unique).


* the relation configuration we put it in the entity configuration that has FK

* Billing Address:   عنوان الفواتير => الخاص بالدفع.
* Shipping Address:  عنوان الشحن => المنتج يتبعت عليه.

* the relation between order and address i am still can't get it right            
    one address has many orders: زي مثلا العميل عمل 3 طلبات مختلفة في 3 أيام، وكلهم استخدموا نفس العنوان للشحن 

* why i stored AddressTypeEnum as string in db and OrderStatus as int ?
    because AddressTypeEnum has only 2 values and they rarely change, so storing them as string is fine and makes the db more readable
    but OrderStatus has many values and might change in the future, so storing them as int is better for performance and flexibility

* to solve the problem of services.Configure<ImageKitOptions>(configuration.GetSection("ImageKit")); it tells u serivice does not have configure method 
    u just need to install Microsoft.Extensions.Options.ConfigurationExtensions package

* i used service manager just as wrapper used to collect all service in one place so u just inject one service in the controller 
    but still u need to register all services not just service manager

* for api documentation i used scalar

* We create ByteStore.PresentationLayer because:
    It separates controllers from the main API project.
    It forces controllers to depend only on service contracts (not database/infrastructure).
    It keeps the project clean, maintainable, and flexible for future (REST, gRPC, etc).
    👉 Main API = startup & config.
    👉 Presentation = controllers & HTTP entry point.

* Rules for Naming our routes
    Use nouns, not verbs, in your API URIs to represent resources (e.g., /api/companies, not /api/getCompanies).
    For dependent resources (like employees of a company), structure the URI hierarchically: /api/companies/{companyId}/employees.
    This clear naming convention ensures consistency and understandability before implementing specific "GET" requests.


* Handling Errors and exception
    Error → An expected problem, such as “User not found” or “Password is too short”.
        Best handled with the Result pattern, returning success or failure without breaking program flow.

    Exception → An unexpected problem, such as database crash, null reference, or invalid state.
        Handled with a Global Exception Handler (middleware) to log and return a consistent error response.

    Validation in FluentValidation → Even though invalid input is an expected problem, FluentValidation throws a ValidationException.
        That’s why we typically handle it inside the Global Exception Handler, so the API returns proper error messages.

* Where to apply Rate Limiting?
    ✅ Must have:
        Auth (Login/Register) → prevent brute force.
        Checkout/Payment → prevent spam/fraud.
        Public APIs (e.g., product search, catalog).
    ❌ Usually not needed:
        Admin APIs (unless external admins).
        Internal services (microservices, backend-to-backend).
        Static content (images, CSS, JS → usually via CDN).

* when you use redis for caching ShoppintCart u will ask your self why the key of record is cumstomerId 
    can not the customer make multiple ShoppingCart and the answer when u add new shoppingCart and there another one in the db with same key
    the new will overriwe the old one ok?

 * “The ServiceManager does not replace registering services in the Dependency Injection (DI) container.”

 * Shipping Address: عنوان الشحن
    المكان اللي هييجي له المنتج اللي اشتريته
    مثال: أنا بطلب لابتوب وعايزه يوصل البيت: 123 شارع التحرير، القاهرة
* Billing Address: عنوان الفاتورة/الدفع
    العنوان اللي مربوط بالبطاقة البنكية أو طريقة الدفع
    البطاقة بتاعتي مسجلة في شغلي: 456 شارع الأعمال، القاهرة

* i use Brevo email provider in email Service
* steps to implement Stripe (payment gateway)
    add section in secret.json for stripe contains secret key and publishable key (get them from stripe website under developers/api keys)
    add in app layer in helpers folder class called stripe and configure it in depenency injection 
    install Stripe.net package in infra or persistance layer
    add IPaymentService in app layer and PaymentService in persistance layer and register them 
    add method called Task<Result2<ShoppingCart>> CreateOrUpdatePaymentIntentAsync(string customerId)
        first get shopping cart from IShoppingCartRepo
        get shippingPrice if your app small => make constant value if no use DeliveryMethod table
        calculate subTotal by loop on products that in cart and gete sum 
        then total = subtotal + shoppingPricee
        use PaymentIntentService to create or update intent 
        and then return intentDto with ClientSecret (to frontend) and PaymentIntentId (stored in order)
    u need to go to order service in place order method and add couple of codes to when u place order u need to store paymentIntentId in order too
    and u will solve promblem of duplicate of order too 

* Understand PaymentIntendId and ClientSecret 
    * Stripe Payment Flow
        PaymentIntentId
            stored in order
            Unique ID for the payment created by Stripe.
            Example: pi_3NfFJ3Ksd8xVfV...
            Stored in your backend/database with the order.
            Used to track or update the payment later.
        ClientSecret
            A special token (secret string) tied to the PaymentIntent.
            Example: pi_3NfFJ3Ksd8xVfV_secret_123...
            Sent from your backend → frontend (customer’s browser/app).
            Used by Stripe.js / Stripe Elements to securely collect payment details and he use it in form.
            Only valid for the customer session — safe to share with client.
        put two ids in cart
    * Workflow
        Backend creates a PaymentIntent.
        Stripe returns → PaymentIntentId + ClientSecret.
        Backend saves PaymentIntentId in DB (for tracking).
        Backend sends ClientSecret to frontend.
        Frontend uses ClientSecret to complete the payment (enter card details securely) he use it in form.
        Stripe processes → sends result back (via webhooks).

* important: Summary of the Flow
    Cart = Customer adds products + chooses DeliveryMethod.
    Checkout = Calculate total (Subtotal + Shipping).
    PaymentIntent = Create in Stripe, return ClientSecret to frontend.
    Customer Pays = Stripe processes, sends Webhook if successful.
    Order = If payment succeeded → create Order + link PaymentIntentId.
    Delivery = Ship based on DeliveryMethod.
    Status Updates = Pending → Paid → Shipped → Delivered.

* Authorization: 
    Use [Authorize] → for both Admin & User.
    Use [Authorize(Roles = Roles.AdminRole)] → for Admin-only.
    Use [Authorize(Roles = Roles.UserRole)] → for User-only.


* Problem:
    You applied a Global Query Filter on Customer so deleted customers are hidden.
    But since Customer is related to other entities (Orders, Reviews, Addresses), you need a best practice for handling these relations without breaking historical data.

* Why not delete related data?
    If you soft-delete a customer and their orders/reviews:
        Sales reports break (suddenly lower totals).
        Analytics become inaccurate.
        Historical data is lost (orders are legal/financial records).
    So: Never delete related data like orders/reviews.

* Best Practices

1- Do nothing (most common) ✅
    Keep orders/reviews linked to the deleted customer.
    Because of the query filter, order.Customer may return null.
    In UI, handle this by showing “Deleted User” or just stored info.
2-Denormalization (recommended for Orders) 💡
    Copy customer details (name, email) into the Order at the moment it’s created:
    public class Order
    {
        public Guid CustomerId { get; set; }
        public string CustomerFirstName { get; set; }
        public string CustomerLastName { get; set; }
        public string CustomerEmail { get; set; }
    }
    Benefits:
    Orders remain complete even if customer is deleted.
    No need for joins with Customer table.
    Better performance.
3- Nullable foreign keys (not recommended) 👎
    Setting CustomerId to null after deletion breaks the link.
    You lose important business data (who made the order).

* Recommendations for Your Project
    Orders → use Denormalization (copy customer info at order creation).
    Addresses → use Do nothing (address tied to deleted customer is fine).
    ProductReviews → use Do nothing (show “Deleted User” if needed).
    This way:
        Query filter hides deleted customers.
        Orders keep accurate historical data.
        Analytics and reports remain correct.

👉 For Products, use IsActive instead of IsDeleted:
    IsActive = true: product visible in catalog.
    IsActive = false: hidden from catalog but still referenced in past orders.
    Always denormalize product info into OrderItem (name, price, image) at purchase time.

For unit tests i am using xunit, fluent assertion , moq
    don't forget to add application refrence from unit tests to application layer
    and don't forget to add this code to access internal 
        <ItemGroup>
		    <AssymblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleToAttribute">
			    <_Parameter1>ByteStore.Application.UnitTests</_Parameter1>
		    </AssymblyAttribute>
	    </ItemGroup>

* problem when using role manager , user manager when i use async 
    When testing services that use EF Core async LINQ methods (like ToListAsync or FirstOrDefaultAsync), 
    you get an error: "The provider for the source 'IQueryable' doesn't implement IAsyncQueryProvider."
    Reason:
        In tests you usually use List<T>.AsQueryable(). That creates a normal IQueryable,
        but it doesn’t support async queries. EF Core async methods need an IAsyncQueryProvider.
    Solutions:
        1-Change ToListAsync to ToList in your service (easy but less realistic).
        2-Use a repository abstraction that returns plain lists (more boilerplate).
        3-Use EF InMemory database for tests (realistic, async works, but heavier).
        4-Use a helper that simulates EF async queries (best for unit tests) 
            => that was i use it u can see a helper method in testing proj
            Keep service code unchanged with ToListAsync / FirstOrDefaultAsync. In tests,
            instead of using List<T>.AsQueryable(), wrap your data with TestAsyncEnumerable<T>.
            This provides IAsyncQueryProvider, so async LINQ works in tests just like in production.

* i did pagination and fitlering and sorting and searching features for products
    Question: Should I apply Skip & Take first, or should I apply Filter, Search, and Sort first?
        Correct way: You should always apply Filtering + Searching + Sorting first.
        Because you want the data to be fully filtered and sorted before selecting the page.
        If you apply Skip & Take first, you’ll end up cutting the wrong data 
        (for example, you might fetch a page from data that isn’t filtered or sorted yet).
    ✅ The correct order is:
        Filter
        Search
        Sort
        Skip & Take (Pagination)

// TODO:
    don't forget to return all authorize attributes
    edit category with imageUrl
    test all things
    solve problem of fluent validation  
        but other exceptions work well => not it does not work :()